"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@langchain";
exports.ids = ["vendor-chunks/@langchain"];
exports.modules = {

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/client.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/client.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssistantsClient: () => (/* binding */ AssistantsClient),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CronsClient: () => (/* binding */ CronsClient),\n/* harmony export */   RunsClient: () => (/* binding */ RunsClient),\n/* harmony export */   StoreClient: () => (/* binding */ StoreClient),\n/* harmony export */   ThreadsClient: () => (/* binding */ ThreadsClient),\n/* harmony export */   getApiKey: () => (/* binding */ getApiKey)\n/* harmony export */ });\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_eventsource_parser_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/eventsource-parser/index.js */ \"(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/eventsource-parser/index.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/stream.js */ \"(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js\");\n/* harmony import */ var _utils_signals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/signals.js */ \"(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/env.js */ \"(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js\");\n\n\n\n\n\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - Optional API key provided as an argument\n * @returns The API key if found, otherwise undefined\n */\nfunction getApiKey(apiKey) {\n    if (apiKey) {\n        return apiKey;\n    }\n    const prefixes = [\"LANGGRAPH\", \"LANGSMITH\", \"LANGCHAIN\"];\n    for (const prefix of prefixes) {\n        const envKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(`${prefix}_API_KEY`);\n        if (envKey) {\n            // Remove surrounding quotes\n            return envKey.trim().replace(/^[\"']|[\"']$/g, \"\");\n        }\n    }\n    return undefined;\n}\nclass BaseClient {\n    constructor(config) {\n        Object.defineProperty(this, \"asyncCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeoutMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultHeaders\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.asyncCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller({\n            maxRetries: 4,\n            maxConcurrency: 4,\n            ...config?.callerOptions,\n        });\n        this.timeoutMs = config?.timeoutMs || 12_000;\n        // default limit being capped by Chrome\n        // https://github.com/nodejs/undici/issues/1373\n        // Regex to remove trailing slash, if present\n        this.apiUrl = config?.apiUrl?.replace(/\\/$/, \"\") || \"http://localhost:8123\";\n        this.defaultHeaders = config?.defaultHeaders || {};\n        const apiKey = getApiKey(config?.apiKey);\n        if (apiKey) {\n            this.defaultHeaders[\"X-Api-Key\"] = apiKey;\n        }\n    }\n    prepareFetchOptions(path, options) {\n        const mutatedOptions = {\n            ...options,\n            headers: { ...this.defaultHeaders, ...options?.headers },\n        };\n        if (mutatedOptions.json) {\n            mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n            mutatedOptions.headers = {\n                ...mutatedOptions.headers,\n                \"Content-Type\": \"application/json\",\n            };\n            delete mutatedOptions.json;\n        }\n        let timeoutSignal = null;\n        if (typeof options?.timeoutMs !== \"undefined\") {\n            if (options.timeoutMs != null) {\n                timeoutSignal = AbortSignal.timeout(options.timeoutMs);\n            }\n        }\n        else {\n            timeoutSignal = AbortSignal.timeout(this.timeoutMs);\n        }\n        mutatedOptions.signal = (0,_utils_signals_js__WEBPACK_IMPORTED_MODULE_3__.mergeSignals)(timeoutSignal, mutatedOptions.signal);\n        const targetUrl = new URL(`${this.apiUrl}${path}`);\n        if (mutatedOptions.params) {\n            for (const [key, value] of Object.entries(mutatedOptions.params)) {\n                if (value == null)\n                    continue;\n                let strValue = typeof value === \"string\" || typeof value === \"number\"\n                    ? value.toString()\n                    : JSON.stringify(value);\n                targetUrl.searchParams.append(key, strValue);\n            }\n            delete mutatedOptions.params;\n        }\n        return [targetUrl, mutatedOptions];\n    }\n    async fetch(path, options) {\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(path, options));\n        if (response.status === 202 || response.status === 204) {\n            return undefined;\n        }\n        return response.json();\n    }\n}\nclass CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    async createForThread(threadId, assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n        };\n        return this.fetch(`/threads/${threadId}/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    async create(assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n        };\n        return this.fetch(`/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    async delete(cronId) {\n        await this.fetch(`/runs/crons/${cronId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    async search(query) {\n        return this.fetch(\"/runs/crons/search\", {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n            },\n        });\n    }\n}\nclass AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    async get(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`);\n    }\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    async getGraph(assistantId, options) {\n        return this.fetch(`/assistants/${assistantId}/graph`, {\n            params: { xray: options?.xray },\n        });\n    }\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    async getSchemas(assistantId) {\n        return this.fetch(`/assistants/${assistantId}/schemas`);\n    }\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    async getSubgraphs(assistantId, options) {\n        if (options?.namespace) {\n            return this.fetch(`/assistants/${assistantId}/subgraphs/${options.namespace}`, { params: { recurse: options?.recurse } });\n        }\n        return this.fetch(`/assistants/${assistantId}/subgraphs`, {\n            params: { recurse: options?.recurse },\n        });\n    }\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    async create(payload) {\n        return this.fetch(\"/assistants\", {\n            method: \"POST\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                metadata: payload.metadata,\n                assistant_id: payload.assistantId,\n                if_exists: payload.ifExists,\n                name: payload.name,\n            },\n        });\n    }\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    async update(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"PATCH\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                metadata: payload.metadata,\n                name: payload.name,\n            },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    async delete(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants.\n     */\n    async search(query) {\n        return this.fetch(\"/assistants/search\", {\n            method: \"POST\",\n            json: {\n                graph_id: query?.graphId ?? undefined,\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    async getVersions(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}/versions`, {\n            method: \"POST\",\n            json: {\n                metadata: payload?.metadata ?? undefined,\n                limit: payload?.limit ?? 10,\n                offset: payload?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    async setLatest(assistantId, version) {\n        return this.fetch(`/assistants/${assistantId}/latest`, {\n            method: \"POST\",\n            json: { version },\n        });\n    }\n}\nclass ThreadsClient extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    async get(threadId) {\n        return this.fetch(`/threads/${threadId}`);\n    }\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    async create(payload) {\n        return this.fetch(`/threads`, {\n            method: \"POST\",\n            json: {\n                metadata: payload?.metadata,\n                thread_id: payload?.threadId,\n                if_exists: payload?.ifExists,\n            },\n        });\n    }\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    async copy(threadId) {\n        return this.fetch(`/threads/${threadId}/copy`, {\n            method: \"POST\",\n        });\n    }\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    async update(threadId, payload) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"PATCH\",\n            json: { metadata: payload?.metadata },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    async delete(threadId) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    async search(query) {\n        return this.fetch(\"/threads/search\", {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                status: query?.status,\n            },\n        });\n    }\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    async getState(threadId, checkpoint, options) {\n        if (checkpoint != null) {\n            if (typeof checkpoint !== \"string\") {\n                return this.fetch(`/threads/${threadId}/state/checkpoint`, {\n                    method: \"POST\",\n                    json: { checkpoint, subgraphs: options?.subgraphs },\n                });\n            }\n            // deprecated\n            return this.fetch(`/threads/${threadId}/state/${checkpoint}`, { params: { subgraphs: options?.subgraphs } });\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            params: { subgraphs: options?.subgraphs },\n        });\n    }\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    async updateState(threadId, options) {\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"POST\",\n            json: {\n                values: options.values,\n                checkpoint_id: options.checkpointId,\n                checkpoint: options.checkpoint,\n                as_node: options?.asNode,\n            },\n        });\n    }\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    async patchState(threadIdOrConfig, metadata) {\n        let threadId;\n        if (typeof threadIdOrConfig !== \"string\") {\n            if (typeof threadIdOrConfig.configurable.thread_id !== \"string\") {\n                throw new Error(\"Thread ID is required when updating state with a config.\");\n            }\n            threadId = threadIdOrConfig.configurable.thread_id;\n        }\n        else {\n            threadId = threadIdOrConfig;\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"PATCH\",\n            json: { metadata: metadata },\n        });\n    }\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    async getHistory(threadId, options) {\n        return this.fetch(`/threads/${threadId}/history`, {\n            method: \"POST\",\n            json: {\n                limit: options?.limit ?? 10,\n                before: options?.before,\n                metadata: options?.metadata,\n                checkpoint: options?.checkpoint,\n            },\n        });\n    }\n}\nclass RunsClient extends BaseClient {\n    /**\n     * Create a run and stream the results.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     */\n    async *stream(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            feedback_keys: payload?.feedbackKeys,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n        };\n        const endpoint = threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`;\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n        }));\n        let parser;\n        let onEndEvent;\n        const textDecoder = new TextDecoder();\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() })).pipeThrough(new TransformStream({\n            async start(ctrl) {\n                parser = (0,_utils_eventsource_parser_index_js__WEBPACK_IMPORTED_MODULE_1__.createParser)((event) => {\n                    if ((payload?.signal && payload.signal.aborted) ||\n                        (event.type === \"event\" && event.data === \"[DONE]\")) {\n                        ctrl.terminate();\n                        return;\n                    }\n                    if (\"data\" in event) {\n                        ctrl.enqueue({\n                            event: event.event ?? \"message\",\n                            data: JSON.parse(event.data),\n                        });\n                    }\n                });\n                onEndEvent = () => {\n                    ctrl.enqueue({ event: \"end\", data: undefined });\n                };\n            },\n            async transform(chunk) {\n                const payload = textDecoder.decode(chunk);\n                parser.feed(payload);\n                // eventsource-parser will ignore events\n                // that are not terminated by a newline\n                if (payload.trim() === \"event: end\")\n                    onEndEvent();\n            },\n        }));\n        yield* _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    async create(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            multitask_strategy: payload?.multitaskStrategy,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n        };\n        return this.fetch(`/threads/${threadId}/runs`, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n        });\n    }\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    async createBatch(payloads) {\n        const filteredPayloads = payloads\n            .map((payload) => ({ ...payload, assistant_id: payload.assistantId }))\n            .map((payload) => {\n            return Object.fromEntries(Object.entries(payload).filter(([_, v]) => v !== undefined));\n        });\n        return this.fetch(\"/runs/batch\", {\n            method: \"POST\",\n            json: filteredPayloads,\n        });\n    }\n    /**\n     * Create a run and wait for it to complete.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The last values chunk of the thread.\n     */\n    async wait(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n        };\n        const endpoint = threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n        const response = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n        });\n        const raiseError = payload?.raiseError !== undefined ? payload.raiseError : true;\n        if (raiseError &&\n            \"__error__\" in response &&\n            typeof response.__error__ === \"object\" &&\n            response.__error__ &&\n            \"error\" in response.__error__ &&\n            \"message\" in response.__error__) {\n            throw new Error(`${response.__error__?.error}: ${response.__error__?.message}`);\n        }\n        return response;\n    }\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    async list(threadId, options) {\n        return this.fetch(`/threads/${threadId}/runs`, {\n            params: {\n                limit: options?.limit ?? 10,\n                offset: options?.offset ?? 0,\n                status: options?.status ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    async get(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`);\n    }\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    async cancel(threadId, runId, wait = false, action = \"interrupt\") {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/cancel`, {\n            method: \"POST\",\n            params: {\n                wait: wait ? \"1\" : \"0\",\n                action: action,\n            },\n        });\n    }\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async join(threadId, runId, options) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/join`, {\n            timeoutMs: null,\n            signal: options?.signal,\n        });\n    }\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     * Output is not buffered, so any output produced before this call will\n     * not be received here.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns An async generator yielding stream parts.\n     */\n    async *joinStream(threadId, runId, options) {\n        const opts = typeof options === \"object\" &&\n            options != null &&\n            options instanceof AbortSignal\n            ? { signal: options }\n            : options;\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(`/threads/${threadId}/runs/${runId}/stream`, {\n            method: \"GET\",\n            timeoutMs: null,\n            signal: opts?.signal,\n            params: { cancel_on_disconnect: opts?.cancelOnDisconnect ? \"1\" : \"0\" },\n        }));\n        let parser;\n        let onEndEvent;\n        const textDecoder = new TextDecoder();\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() })).pipeThrough(new TransformStream({\n            async start(ctrl) {\n                parser = (0,_utils_eventsource_parser_index_js__WEBPACK_IMPORTED_MODULE_1__.createParser)((event) => {\n                    if ((opts?.signal && opts.signal.aborted) ||\n                        (event.type === \"event\" && event.data === \"[DONE]\")) {\n                        ctrl.terminate();\n                        return;\n                    }\n                    if (\"data\" in event) {\n                        ctrl.enqueue({\n                            event: event.event ?? \"message\",\n                            data: JSON.parse(event.data),\n                        });\n                    }\n                });\n                onEndEvent = () => {\n                    ctrl.enqueue({ event: \"end\", data: undefined });\n                };\n            },\n            async transform(chunk) {\n                const payload = textDecoder.decode(chunk);\n                parser.feed(payload);\n                // eventsource-parser will ignore events\n                // that are not terminated by a newline\n                if (payload.trim() === \"event: end\")\n                    onEndEvent();\n            },\n        }));\n        yield* _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async delete(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`, {\n            method: \"DELETE\",\n        });\n    }\n}\nclass StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @returns Promise<void>\n     */\n    async putItem(namespace, key, value) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const payload = {\n            namespace,\n            key,\n            value,\n        };\n        return this.fetch(\"/store/items\", {\n            method: \"PUT\",\n            json: payload,\n        });\n    }\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<Item>\n     */\n    async getItem(namespace, key) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const response = await this.fetch(\"/store/items\", {\n            params: { namespace: namespace.join(\".\"), key },\n        });\n        return response\n            ? {\n                ...response,\n                createdAt: response.created_at,\n                updatedAt: response.updated_at,\n            }\n            : null;\n    }\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    async deleteItem(namespace, key) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        return this.fetch(\"/store/items\", {\n            method: \"DELETE\",\n            json: { namespace, key },\n        });\n    }\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @returns Promise<SearchItemsResponse>\n     */\n    async searchItems(namespacePrefix, options) {\n        const payload = {\n            namespace_prefix: namespacePrefix,\n            filter: options?.filter,\n            limit: options?.limit ?? 10,\n            offset: options?.offset ?? 0,\n            query: options?.query,\n        };\n        const response = await this.fetch(\"/store/items/search\", {\n            method: \"POST\",\n            json: payload,\n        });\n        return {\n            items: response.items.map((item) => ({\n                ...item,\n                createdAt: item.created_at,\n                updatedAt: item.updated_at,\n            })),\n        };\n    }\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    async listNamespaces(options) {\n        const payload = {\n            prefix: options?.prefix,\n            suffix: options?.suffix,\n            max_depth: options?.maxDepth,\n            limit: options?.limit ?? 100,\n            offset: options?.offset ?? 0,\n        };\n        return this.fetch(\"/store/namespaces\", {\n            method: \"POST\",\n            json: payload,\n        });\n    }\n}\nclass Client {\n    constructor(config) {\n        /**\n         * The client for interacting with assistants.\n         */\n        Object.defineProperty(this, \"assistants\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with threads.\n         */\n        Object.defineProperty(this, \"threads\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with runs.\n         */\n        Object.defineProperty(this, \"runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with cron runs.\n         */\n        Object.defineProperty(this, \"crons\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the KV store.\n         */\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.assistants = new AssistantsClient(config);\n        this.threads = new ThreadsClient(config);\n        this.runs = new RunsClient(config);\n        this.crons = new CronsClient(config);\n        this.store = new StoreClient(config);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUNjO0FBQ1Q7QUFDVDtBQUNNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUVBQXNCLElBQUksT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQiwrREFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBNkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFZO0FBQzVDLHFDQUFxQyxZQUFZLEVBQUUsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdXN0ZW4vRGV2ZWxvcG1lbnQvdXB3YWdlL2ludGVydmlldy1vcmNoZXN0cmF0aW9uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi91dGlscy9hc3luY19jYWxsZXIuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVBhcnNlciwgfSBmcm9tIFwiLi91dGlscy9ldmVudHNvdXJjZS1wYXJzZXIvaW5kZXguanNcIjtcbmltcG9ydCB7IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gfSBmcm9tIFwiLi91dGlscy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IG1lcmdlU2lnbmFscyB9IGZyb20gXCIuL3V0aWxzL3NpZ25hbHMuanNcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbi8qKlxuICogR2V0IHRoZSBBUEkga2V5IGZyb20gdGhlIGVudmlyb25tZW50LlxuICogUHJlY2VkZW5jZTpcbiAqICAgMS4gZXhwbGljaXQgYXJndW1lbnRcbiAqICAgMi4gTEFOR0dSQVBIX0FQSV9LRVlcbiAqICAgMy4gTEFOR1NNSVRIX0FQSV9LRVlcbiAqICAgNC4gTEFOR0NIQUlOX0FQSV9LRVlcbiAqXG4gKiBAcGFyYW0gYXBpS2V5IC0gT3B0aW9uYWwgQVBJIGtleSBwcm92aWRlZCBhcyBhbiBhcmd1bWVudFxuICogQHJldHVybnMgVGhlIEFQSSBrZXkgaWYgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBhcGlLZXk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeGVzID0gW1wiTEFOR0dSQVBIXCIsIFwiTEFOR1NNSVRIXCIsIFwiTEFOR0NIQUlOXCJdO1xuICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICAgIGNvbnN0IGVudktleSA9IGdldEVudmlyb25tZW50VmFyaWFibGUoYCR7cHJlZml4fV9BUElfS0VZYCk7XG4gICAgICAgIGlmIChlbnZLZXkpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzdXJyb3VuZGluZyBxdW90ZXNcbiAgICAgICAgICAgIHJldHVybiBlbnZLZXkudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbXCInXSQvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIEJhc2VDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhc3luY0NhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRIZWFkZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXN5bmNDYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgbWF4UmV0cmllczogNCxcbiAgICAgICAgICAgIG1heENvbmN1cnJlbmN5OiA0LFxuICAgICAgICAgICAgLi4uY29uZmlnPy5jYWxsZXJPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50aW1lb3V0TXMgPSBjb25maWc/LnRpbWVvdXRNcyB8fCAxMl8wMDA7XG4gICAgICAgIC8vIGRlZmF1bHQgbGltaXQgYmVpbmcgY2FwcGVkIGJ5IENocm9tZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTM3M1xuICAgICAgICAvLyBSZWdleCB0byByZW1vdmUgdHJhaWxpbmcgc2xhc2gsIGlmIHByZXNlbnRcbiAgICAgICAgdGhpcy5hcGlVcmwgPSBjb25maWc/LmFwaVVybD8ucmVwbGFjZSgvXFwvJC8sIFwiXCIpIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MTIzXCI7XG4gICAgICAgIHRoaXMuZGVmYXVsdEhlYWRlcnMgPSBjb25maWc/LmRlZmF1bHRIZWFkZXJzIHx8IHt9O1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRBcGlLZXkoY29uZmlnPy5hcGlLZXkpO1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRIZWFkZXJzW1wiWC1BcGktS2V5XCJdID0gYXBpS2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVGZXRjaE9wdGlvbnMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtdXRhdGVkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuZGVmYXVsdEhlYWRlcnMsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG11dGF0ZWRPcHRpb25zLmpzb24pIHtcbiAgICAgICAgICAgIG11dGF0ZWRPcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShtdXRhdGVkT3B0aW9ucy5qc29uKTtcbiAgICAgICAgICAgIG11dGF0ZWRPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgLi4ubXV0YXRlZE9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWxldGUgbXV0YXRlZE9wdGlvbnMuanNvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZW91dFNpZ25hbCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucz8udGltZW91dE1zICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0TXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRTaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KG9wdGlvbnMudGltZW91dE1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVvdXRTaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dE1zKTtcbiAgICAgICAgfVxuICAgICAgICBtdXRhdGVkT3B0aW9ucy5zaWduYWwgPSBtZXJnZVNpZ25hbHModGltZW91dFNpZ25hbCwgbXV0YXRlZE9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VXJsID0gbmV3IFVSTChgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCk7XG4gICAgICAgIGlmIChtdXRhdGVkT3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG11dGF0ZWRPcHRpb25zLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0clZhbHVlID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBzdHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbXV0YXRlZE9wdGlvbnMucGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFyZ2V0VXJsLCBtdXRhdGVkT3B0aW9uc107XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFzeW5jQ2FsbGVyLmZldGNoKC4uLnRoaXMucHJlcGFyZUZldGNoT3B0aW9ucyhwYXRoLCBvcHRpb25zKSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMiB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDcm9uc0NsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBBc3Npc3RhbnQgSUQgdG8gdXNlIGZvciB0aGlzIGNyb24gam9iLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgY3JvbiBqb2IuXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYmFja2dyb3VuZCBydW4uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRm9yVGhyZWFkKHRocmVhZElkLCBhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgc2NoZWR1bGU6IHBheWxvYWQ/LnNjaGVkdWxlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQ/LmlucHV0LFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIHdlYmhvb2s6IHBheWxvYWQ/LndlYmhvb2ssXG4gICAgICAgICAgICBtdWx0aXRhc2tfc3RyYXRlZ3k6IHBheWxvYWQ/Lm11bHRpdGFza1N0cmF0ZWd5LFxuICAgICAgICAgICAgaWZfbm90X2V4aXN0czogcGF5bG9hZD8uaWZOb3RFeGlzdHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zL2Nyb25zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBBc3Npc3RhbnQgSUQgdG8gdXNlIGZvciB0aGlzIGNyb24gam9iLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgY3JvbiBqb2IuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUoYXNzaXN0YW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIHNjaGVkdWxlOiBwYXlsb2FkPy5zY2hlZHVsZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkPy5pbnB1dCxcbiAgICAgICAgICAgIGNvbmZpZzogcGF5bG9hZD8uY29uZmlnLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBhc3Npc3RhbnRJZCxcbiAgICAgICAgICAgIGludGVycnVwdF9iZWZvcmU6IHBheWxvYWQ/LmludGVycnVwdEJlZm9yZSxcbiAgICAgICAgICAgIGludGVycnVwdF9hZnRlcjogcGF5bG9hZD8uaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICB3ZWJob29rOiBwYXlsb2FkPy53ZWJob29rLFxuICAgICAgICAgICAgbXVsdGl0YXNrX3N0cmF0ZWd5OiBwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSxcbiAgICAgICAgICAgIGlmX25vdF9leGlzdHM6IHBheWxvYWQ/LmlmTm90RXhpc3RzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3J1bnMvY3JvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNyb25JZCBDcm9uIElEIG9mIENyb24gam9iIHRvIGRlbGV0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoY3JvbklkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZmV0Y2goYC9ydW5zL2Nyb25zLyR7Y3JvbklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IFF1ZXJ5IG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBjcm9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvcnVucy9jcm9ucy9zZWFyY2hcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IHF1ZXJ5Py5hc3Npc3RhbnRJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGhyZWFkX2lkOiBxdWVyeT8udGhyZWFkSWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBxdWVyeT8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBxdWVyeT8ub2Zmc2V0ID8/IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXNzaXN0YW50c0NsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdldCBhbiBhc3Npc3RhbnQgYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgVGhlIElEIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICogQHJldHVybnMgQXNzaXN0YW50XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KGFzc2lzdGFudElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGdyYXBoIGFzc2lnbmVkIHRvIGEgcnVubmFibGVcbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgVGhlIElEIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMueHJheSBXaGV0aGVyIHRvIGluY2x1ZGUgc3ViZ3JhcGhzIGluIHRoZSBzZXJpYWxpemVkIGdyYXBoIHJlcHJlc2VudGF0aW9uLiBJZiBhbiBpbnRlZ2VyIHZhbHVlIGlzIHByb3ZpZGVkLCBvbmx5IHN1YmdyYXBocyB3aXRoIGEgZGVwdGggbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSB3aWxsIGJlIGluY2x1ZGVkLlxuICAgICAqIEByZXR1cm5zIFNlcmlhbGl6ZWQgZ3JhcGhcbiAgICAgKi9cbiAgICBhc3luYyBnZXRHcmFwaChhc3Npc3RhbnRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH0vZ3JhcGhgLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHsgeHJheTogb3B0aW9ucz8ueHJheSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0ZSBhbmQgY29uZmlnIHNjaGVtYSBvZiB0aGUgZ3JhcGggYXNzaWduZWQgdG8gYSBydW5uYWJsZVxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBUaGUgSUQgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKiBAcmV0dXJucyBHcmFwaCBzY2hlbWFcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTY2hlbWFzKGFzc2lzdGFudElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfS9zY2hlbWFzYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2NoZW1hcyBvZiBhbiBhc3Npc3RhbnQgYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgVGhlIElEIG9mIHRoZSBhc3Npc3RhbnQgdG8gZ2V0IHRoZSBzY2hlbWEgb2YuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHN1YmdyYXBocywgc3VjaCBhcyBuYW1lc3BhY2Ugb3IgcmVjdXJzaW9uIGV4dHJhY3Rpb24uXG4gICAgICogQHJldHVybnMgVGhlIHN1YmdyYXBocyBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFN1YmdyYXBocyhhc3Npc3RhbnRJZCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucz8ubmFtZXNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH0vc3ViZ3JhcGhzLyR7b3B0aW9ucy5uYW1lc3BhY2V9YCwgeyBwYXJhbXM6IHsgcmVjdXJzZTogb3B0aW9ucz8ucmVjdXJzZSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfS9zdWJncmFwaHNgLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHsgcmVjdXJzZTogb3B0aW9ucz8ucmVjdXJzZSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFzc2lzdGFudC5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhbiBhc3Npc3RhbnQuXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYXNzaXN0YW50LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiL2Fzc2lzdGFudHNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBncmFwaF9pZDogcGF5bG9hZC5ncmFwaElkLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcGF5bG9hZC5jb25maWcsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBwYXlsb2FkLmFzc2lzdGFudElkLFxuICAgICAgICAgICAgICAgIGlmX2V4aXN0czogcGF5bG9hZC5pZkV4aXN0cyxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLm5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGFzc2lzdGFudC5cbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgSUQgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciB1cGRhdGluZyB0aGUgYXNzaXN0YW50LlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoYXNzaXN0YW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgZ3JhcGhfaWQ6IHBheWxvYWQuZ3JhcGhJZCxcbiAgICAgICAgICAgICAgICBjb25maWc6IHBheWxvYWQuY29uZmlnLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQubmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gYXNzaXN0YW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIElEIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGFzc2lzdGFudElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXNzaXN0YW50cy5cbiAgICAgKiBAcGFyYW0gcXVlcnkgUXVlcnkgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGFzc2lzdGFudHMuXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiL2Fzc2lzdGFudHMvc2VhcmNoXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgZ3JhcGhfaWQ6IHF1ZXJ5Py5ncmFwaElkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcXVlcnk/Lm1ldGFkYXRhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsaW1pdDogcXVlcnk/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIG9mZnNldDogcXVlcnk/Lm9mZnNldCA/PyAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHZlcnNpb25zIG9mIGFuIGFzc2lzdGFudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgYXNzaXN0YW50IHZlcnNpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFZlcnNpb25zKGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfS92ZXJzaW9uc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsaW1pdDogcGF5bG9hZD8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXlsb2FkPy5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIHZlcnNpb24gb2YgYW4gYXNzaXN0YW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIElEIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIHZlcnNpb24gdG8gY2hhbmdlIHRvLlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRMYXRlc3QoYXNzaXN0YW50SWQsIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9L2xhdGVzdGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7IHZlcnNpb24gfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRocmVhZHNDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSB0aHJlYWQgYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdGhyZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldCh0aHJlYWRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgdGhyZWFkLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHRocmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB0aHJlYWRfaWQ6IHBheWxvYWQ/LnRocmVhZElkLFxuICAgICAgICAgICAgICAgIGlmX2V4aXN0czogcGF5bG9hZD8uaWZFeGlzdHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29weSBhbiBleGlzdGluZyB0aHJlYWRcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgSUQgb2YgdGhlIHRocmVhZCB0byBiZSBjb3BpZWRcbiAgICAgKiBAcmV0dXJucyBOZXdseSBjb3BpZWQgdGhyZWFkXG4gICAgICovXG4gICAgYXN5bmMgY29weSh0aHJlYWRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vY29weWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciB1cGRhdGluZyB0aGUgdGhyZWFkLlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIHRocmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUodGhyZWFkSWQsIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBqc29uOiB7IG1ldGFkYXRhOiBwYXlsb2FkPy5tZXRhZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHRocmVhZElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdGhyZWFkc1xuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IFF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHRocmVhZHNcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvdGhyZWFkcy9zZWFyY2hcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcXVlcnk/Lm1ldGFkYXRhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsaW1pdDogcXVlcnk/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIG9mZnNldDogcXVlcnk/Lm9mZnNldCA/PyAwLFxuICAgICAgICAgICAgICAgIHN0YXR1czogcXVlcnk/LnN0YXR1cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc3RhdGUgZm9yIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHJldHVybnMgVGhyZWFkIHN0YXRlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRlKHRocmVhZElkLCBjaGVja3BvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChjaGVja3BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hlY2twb2ludCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9zdGF0ZS9jaGVja3BvaW50YCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7IGNoZWNrcG9pbnQsIHN1YmdyYXBoczogb3B0aW9ucz8uc3ViZ3JhcGhzIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vc3RhdGUvJHtjaGVja3BvaW50fWAsIHsgcGFyYW1zOiB7IHN1YmdyYXBoczogb3B0aW9ucz8uc3ViZ3JhcGhzIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3N0YXRlYCwge1xuICAgICAgICAgICAgcGFyYW1zOiB7IHN1YmdyYXBoczogb3B0aW9ucz8uc3ViZ3JhcGhzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc3RhdGUgdG8gYSB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTdGF0ZSh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vc3RhdGVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlczogb3B0aW9ucy52YWx1ZXMsXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogb3B0aW9ucy5jaGVja3BvaW50SWQsXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludDogb3B0aW9ucy5jaGVja3BvaW50LFxuICAgICAgICAgICAgICAgIGFzX25vZGU6IG9wdGlvbnM/LmFzTm9kZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXRjaCB0aGUgbWV0YWRhdGEgb2YgYSB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWRPckNvbmZpZyBUaHJlYWQgSUQgb3IgY29uZmlnIHRvIHBhdGNoIHRoZSBzdGF0ZSBvZi5cbiAgICAgKiBAcGFyYW0gbWV0YWRhdGEgTWV0YWRhdGEgdG8gcGF0Y2ggdGhlIHN0YXRlIHdpdGguXG4gICAgICovXG4gICAgYXN5bmMgcGF0Y2hTdGF0ZSh0aHJlYWRJZE9yQ29uZmlnLCBtZXRhZGF0YSkge1xuICAgICAgICBsZXQgdGhyZWFkSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGhyZWFkSWRPckNvbmZpZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aHJlYWRJZE9yQ29uZmlnLmNvbmZpZ3VyYWJsZS50aHJlYWRfaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaHJlYWQgSUQgaXMgcmVxdWlyZWQgd2hlbiB1cGRhdGluZyBzdGF0ZSB3aXRoIGEgY29uZmlnLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocmVhZElkID0gdGhyZWFkSWRPckNvbmZpZy5jb25maWd1cmFibGUudGhyZWFkX2lkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyZWFkSWQgPSB0aHJlYWRJZE9yQ29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9zdGF0ZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAganNvbjogeyBtZXRhZGF0YTogbWV0YWRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcGFzdCBzdGF0ZXMgZm9yIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgdGhyZWFkIHN0YXRlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRIaXN0b3J5KHRocmVhZElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9oaXN0b3J5YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBsaW1pdDogb3B0aW9ucz8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBvcHRpb25zPy5iZWZvcmUsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG9wdGlvbnM/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQ6IG9wdGlvbnM/LmNoZWNrcG9pbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVuc0NsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJ1biBhbmQgc3RyZWFtIHRoZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBBc3Npc3RhbnQgSUQgdG8gdXNlIGZvciB0aGlzIHJ1bi5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhIHJ1bi5cbiAgICAgKi9cbiAgICBhc3luYyAqc3RyZWFtKHRocmVhZElkLCBhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQ/LmlucHV0LFxuICAgICAgICAgICAgY29tbWFuZDogcGF5bG9hZD8uY29tbWFuZCxcbiAgICAgICAgICAgIGNvbmZpZzogcGF5bG9hZD8uY29uZmlnLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgc3RyZWFtX21vZGU6IHBheWxvYWQ/LnN0cmVhbU1vZGUsXG4gICAgICAgICAgICBzdHJlYW1fc3ViZ3JhcGhzOiBwYXlsb2FkPy5zdHJlYW1TdWJncmFwaHMsXG4gICAgICAgICAgICBmZWVkYmFja19rZXlzOiBwYXlsb2FkPy5mZWVkYmFja0tleXMsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIGNoZWNrcG9pbnQ6IHBheWxvYWQ/LmNoZWNrcG9pbnQsXG4gICAgICAgICAgICBjaGVja3BvaW50X2lkOiBwYXlsb2FkPy5jaGVja3BvaW50SWQsXG4gICAgICAgICAgICB3ZWJob29rOiBwYXlsb2FkPy53ZWJob29rLFxuICAgICAgICAgICAgbXVsdGl0YXNrX3N0cmF0ZWd5OiBwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSxcbiAgICAgICAgICAgIG9uX2NvbXBsZXRpb246IHBheWxvYWQ/Lm9uQ29tcGxldGlvbixcbiAgICAgICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IHBheWxvYWQ/Lm9uRGlzY29ubmVjdCxcbiAgICAgICAgICAgIGFmdGVyX3NlY29uZHM6IHBheWxvYWQ/LmFmdGVyU2Vjb25kcyxcbiAgICAgICAgICAgIGlmX25vdF9leGlzdHM6IHBheWxvYWQ/LmlmTm90RXhpc3RzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHRocmVhZElkID09IG51bGwgPyBgL3J1bnMvc3RyZWFtYCA6IGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zL3N0cmVhbWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hc3luY0NhbGxlci5mZXRjaCguLi50aGlzLnByZXBhcmVGZXRjaE9wdGlvbnMoZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgdGltZW91dE1zOiBudWxsLFxuICAgICAgICAgICAgc2lnbmFsOiBwYXlsb2FkPy5zaWduYWwsXG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IHBhcnNlcjtcbiAgICAgICAgbGV0IG9uRW5kRXZlbnQ7XG4gICAgICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IChyZXNwb25zZS5ib2R5IHx8IG5ldyBSZWFkYWJsZVN0cmVhbSh7IHN0YXJ0OiAoY3RybCkgPT4gY3RybC5jbG9zZSgpIH0pKS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHN0YXJ0KGN0cmwpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSBjcmVhdGVQYXJzZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocGF5bG9hZD8uc2lnbmFsICYmIHBheWxvYWQuc2lnbmFsLmFib3J0ZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZXZlbnQudHlwZSA9PT0gXCJldmVudFwiICYmIGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnQgPz8gXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShldmVudC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25FbmRFdmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5lbnF1ZXVlKHsgZXZlbnQ6IFwiZW5kXCIsIGRhdGE6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgICAgICAgICAgIHBhcnNlci5mZWVkKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50c291cmNlLXBhcnNlciB3aWxsIGlnbm9yZSBldmVudHNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFyZSBub3QgdGVybWluYXRlZCBieSBhIG5ld2xpbmVcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC50cmltKCkgPT09IFwiZXZlbnQ6IGVuZFwiKVxuICAgICAgICAgICAgICAgICAgICBvbkVuZEV2ZW50KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIHlpZWxkKiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byB1c2UgZm9yIHRoaXMgcnVuLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgcnVuLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJ1bi5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUodGhyZWFkSWQsIGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZD8uaW5wdXQsXG4gICAgICAgICAgICBjb21tYW5kOiBwYXlsb2FkPy5jb21tYW5kLFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIHdlYmhvb2s6IHBheWxvYWQ/LndlYmhvb2ssXG4gICAgICAgICAgICBjaGVja3BvaW50OiBwYXlsb2FkPy5jaGVja3BvaW50LFxuICAgICAgICAgICAgY2hlY2twb2ludF9pZDogcGF5bG9hZD8uY2hlY2twb2ludElkLFxuICAgICAgICAgICAgbXVsdGl0YXNrX3N0cmF0ZWd5OiBwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSxcbiAgICAgICAgICAgIGFmdGVyX3NlY29uZHM6IHBheWxvYWQ/LmFmdGVyU2Vjb25kcyxcbiAgICAgICAgICAgIGlmX25vdF9leGlzdHM6IHBheWxvYWQ/LmlmTm90RXhpc3RzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgc2lnbmFsOiBwYXlsb2FkPy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBiYXRjaCBvZiBzdGF0ZWxlc3MgYmFja2dyb3VuZCBydW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBheWxvYWRzIEFuIGFycmF5IG9mIHBheWxvYWRzIGZvciBjcmVhdGluZyBydW5zLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGNyZWF0ZWQgcnVucy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCYXRjaChwYXlsb2Fkcykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFBheWxvYWRzID0gcGF5bG9hZHNcbiAgICAgICAgICAgIC5tYXAoKHBheWxvYWQpID0+ICh7IC4uLnBheWxvYWQsIGFzc2lzdGFudF9pZDogcGF5bG9hZC5hc3Npc3RhbnRJZCB9KSlcbiAgICAgICAgICAgIC5tYXAoKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocGF5bG9hZCkuZmlsdGVyKChbXywgdl0pID0+IHYgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvcnVucy9iYXRjaFwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjogZmlsdGVyZWRQYXlsb2FkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJ1biBhbmQgd2FpdCBmb3IgaXQgdG8gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byB1c2UgZm9yIHRoaXMgcnVuLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgcnVuLlxuICAgICAqIEByZXR1cm5zIFRoZSBsYXN0IHZhbHVlcyBjaHVuayBvZiB0aGUgdGhyZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQodGhyZWFkSWQsIGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZD8uaW5wdXQsXG4gICAgICAgICAgICBjb21tYW5kOiBwYXlsb2FkPy5jb21tYW5kLFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIGNoZWNrcG9pbnQ6IHBheWxvYWQ/LmNoZWNrcG9pbnQsXG4gICAgICAgICAgICBjaGVja3BvaW50X2lkOiBwYXlsb2FkPy5jaGVja3BvaW50SWQsXG4gICAgICAgICAgICB3ZWJob29rOiBwYXlsb2FkPy53ZWJob29rLFxuICAgICAgICAgICAgbXVsdGl0YXNrX3N0cmF0ZWd5OiBwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSxcbiAgICAgICAgICAgIG9uX2NvbXBsZXRpb246IHBheWxvYWQ/Lm9uQ29tcGxldGlvbixcbiAgICAgICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IHBheWxvYWQ/Lm9uRGlzY29ubmVjdCxcbiAgICAgICAgICAgIGFmdGVyX3NlY29uZHM6IHBheWxvYWQ/LmFmdGVyU2Vjb25kcyxcbiAgICAgICAgICAgIGlmX25vdF9leGlzdHM6IHBheWxvYWQ/LmlmTm90RXhpc3RzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHRocmVhZElkID09IG51bGwgPyBgL3J1bnMvd2FpdGAgOiBgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy93YWl0YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRpbWVvdXRNczogbnVsbCxcbiAgICAgICAgICAgIHNpZ25hbDogcGF5bG9hZD8uc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmFpc2VFcnJvciA9IHBheWxvYWQ/LnJhaXNlRXJyb3IgIT09IHVuZGVmaW5lZCA/IHBheWxvYWQucmFpc2VFcnJvciA6IHRydWU7XG4gICAgICAgIGlmIChyYWlzZUVycm9yICYmXG4gICAgICAgICAgICBcIl9fZXJyb3JfX1wiIGluIHJlc3BvbnNlICYmXG4gICAgICAgICAgICB0eXBlb2YgcmVzcG9uc2UuX19lcnJvcl9fID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICByZXNwb25zZS5fX2Vycm9yX18gJiZcbiAgICAgICAgICAgIFwiZXJyb3JcIiBpbiByZXNwb25zZS5fX2Vycm9yX18gJiZcbiAgICAgICAgICAgIFwibWVzc2FnZVwiIGluIHJlc3BvbnNlLl9fZXJyb3JfXykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLl9fZXJyb3JfXz8uZXJyb3J9OiAke3Jlc3BvbnNlLl9fZXJyb3JfXz8ubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHJ1bnMgZm9yIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgcnVucy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KHRocmVhZElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zYCwge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IDAsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBvcHRpb25zPy5zdGF0dXMgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHJ1biBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnMgVGhlIHJ1bi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQodGhyZWFkSWQsIHJ1bklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHBhcmFtIHdhaXQgV2hldGhlciB0byBibG9jayB3aGVuIGNhbmNlbGluZ1xuICAgICAqIEBwYXJhbSBhY3Rpb24gQWN0aW9uIHRvIHRha2Ugd2hlbiBjYW5jZWxsaW5nIHRoZSBydW4uIFBvc3NpYmxlIHZhbHVlcyBhcmUgYGludGVycnVwdGAgb3IgYHJvbGxiYWNrYC4gRGVmYXVsdCBpcyBgaW50ZXJydXB0YC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbCh0aHJlYWRJZCwgcnVuSWQsIHdhaXQgPSBmYWxzZSwgYWN0aW9uID0gXCJpbnRlcnJ1cHRcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9jYW5jZWxgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgd2FpdDogd2FpdCA/IFwiMVwiIDogXCIwXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmxvY2sgdW50aWwgYSBydW4gaXMgZG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBqb2luKHRocmVhZElkLCBydW5JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfS9qb2luYCwge1xuICAgICAgICAgICAgdGltZW91dE1zOiBudWxsLFxuICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb3V0cHV0IGZyb20gYSBydW4gaW4gcmVhbC10aW1lLCB1bnRpbCB0aGUgcnVuIGlzIGRvbmUuXG4gICAgICogT3V0cHV0IGlzIG5vdCBidWZmZXJlZCwgc28gYW55IG91dHB1dCBwcm9kdWNlZCBiZWZvcmUgdGhpcyBjYWxsIHdpbGxcbiAgICAgKiBub3QgYmUgcmVjZWl2ZWQgaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnMgQW4gYXN5bmMgZ2VuZXJhdG9yIHlpZWxkaW5nIHN0cmVhbSBwYXJ0cy5cbiAgICAgKi9cbiAgICBhc3luYyAqam9pblN0cmVhbSh0aHJlYWRJZCwgcnVuSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBvcHRpb25zICE9IG51bGwgJiZcbiAgICAgICAgICAgIG9wdGlvbnMgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbFxuICAgICAgICAgICAgPyB7IHNpZ25hbDogb3B0aW9ucyB9XG4gICAgICAgICAgICA6IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hc3luY0NhbGxlci5mZXRjaCguLi50aGlzLnByZXBhcmVGZXRjaE9wdGlvbnMoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3RyZWFtYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgdGltZW91dE1zOiBudWxsLFxuICAgICAgICAgICAgc2lnbmFsOiBvcHRzPy5zaWduYWwsXG4gICAgICAgICAgICBwYXJhbXM6IHsgY2FuY2VsX29uX2Rpc2Nvbm5lY3Q6IG9wdHM/LmNhbmNlbE9uRGlzY29ubmVjdCA/IFwiMVwiIDogXCIwXCIgfSxcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgcGFyc2VyO1xuICAgICAgICBsZXQgb25FbmRFdmVudDtcbiAgICAgICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gKHJlc3BvbnNlLmJvZHkgfHwgbmV3IFJlYWRhYmxlU3RyZWFtKHsgc3RhcnQ6IChjdHJsKSA9PiBjdHJsLmNsb3NlKCkgfSkpLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgc3RhcnQoY3RybCkge1xuICAgICAgICAgICAgICAgIHBhcnNlciA9IGNyZWF0ZVBhcnNlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChvcHRzPy5zaWduYWwgJiYgb3B0cy5zaWduYWwuYWJvcnRlZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChldmVudC50eXBlID09PSBcImV2ZW50XCIgJiYgZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudC5ldmVudCA/PyBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnBhcnNlKGV2ZW50LmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkVuZEV2ZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmVucXVldWUoeyBldmVudDogXCJlbmRcIiwgZGF0YTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRleHREZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmZlZWQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzb3VyY2UtcGFyc2VyIHdpbGwgaWdub3JlIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYXJlIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgbmV3bGluZVxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLnRyaW0oKSA9PT0gXCJldmVudDogZW5kXCIpXG4gICAgICAgICAgICAgICAgICAgIG9uRW5kRXZlbnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgeWllbGQqIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUodGhyZWFkSWQsIHJ1bklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RvcmVDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBTdG9yZSBvciB1cGRhdGUgYW4gaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgQSBsaXN0IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBuYW1lc3BhY2UgcGF0aC5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGl0ZW0gd2l0aGluIHRoZSBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIEEgZGljdGlvbmFyeSBjb250YWluaW5nIHRoZSBpdGVtJ3MgZGF0YS5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XG4gICAgICovXG4gICAgYXN5bmMgcHV0SXRlbShuYW1lc3BhY2UsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgbmFtZXNwYWNlLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICBpZiAobGFiZWwuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5hbWVzcGFjZSBsYWJlbCAnJHtsYWJlbH0nLiBOYW1lc3BhY2UgbGFiZWxzIGNhbm5vdCBjb250YWluIHBlcmlvZHMgKCcuJylgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvc3RvcmUvaXRlbXNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAganNvbjogcGF5bG9hZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgc2luZ2xlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIEEgbGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbmFtZXNwYWNlIHBhdGguXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBpdGVtLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8SXRlbT5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRJdGVtKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgICAgIG5hbWVzcGFjZS5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuYW1lc3BhY2UgbGFiZWwgJyR7bGFiZWx9Jy4gTmFtZXNwYWNlIGxhYmVscyBjYW5ub3QgY29udGFpbiBwZXJpb2RzICgnLicpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goXCIvc3RvcmUvaXRlbXNcIiwge1xuICAgICAgICAgICAgcGFyYW1zOiB7IG5hbWVzcGFjZTogbmFtZXNwYWNlLmpvaW4oXCIuXCIpLCBrZXkgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiByZXNwb25zZS5jcmVhdGVkX2F0LFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogcmVzcG9uc2UudXBkYXRlZF9hdCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIEEgbGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbmFtZXNwYWNlIHBhdGguXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBpdGVtLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVJdGVtKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgICAgIG5hbWVzcGFjZS5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuYW1lc3BhY2UgbGFiZWwgJyR7bGFiZWx9Jy4gTmFtZXNwYWNlIGxhYmVscyBjYW5ub3QgY29udGFpbiBwZXJpb2RzICgnLicpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9zdG9yZS9pdGVtc1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBqc29uOiB7IG5hbWVzcGFjZSwga2V5IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIGl0ZW1zIHdpdGhpbiBhIG5hbWVzcGFjZSBwcmVmaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlUHJlZml4IExpc3Qgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIG5hbWVzcGFjZSBwcmVmaXguXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmlsdGVyIE9wdGlvbmFsIGRpY3Rpb25hcnkgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGZpbHRlciByZXN1bHRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybiAoZGVmYXVsdCBpcyAxMCkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBpdGVtcyB0byBza2lwIGJlZm9yZSByZXR1cm5pbmcgcmVzdWx0cyAoZGVmYXVsdCBpcyAwKS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWVyeSBPcHRpb25hbCBzZWFyY2ggcXVlcnkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxTZWFyY2hJdGVtc1Jlc3BvbnNlPlxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaEl0ZW1zKG5hbWVzcGFjZVByZWZpeCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgbmFtZXNwYWNlX3ByZWZpeDogbmFtZXNwYWNlUHJlZml4LFxuICAgICAgICAgICAgZmlsdGVyOiBvcHRpb25zPy5maWx0ZXIsXG4gICAgICAgICAgICBsaW1pdDogb3B0aW9ucz8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnM/Lm9mZnNldCA/PyAwLFxuICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnM/LnF1ZXJ5LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goXCIvc3RvcmUvaXRlbXMvc2VhcmNoXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiBwYXlsb2FkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGl0ZW1zOiByZXNwb25zZS5pdGVtcy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGl0ZW0uY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IGl0ZW0udXBkYXRlZF9hdCxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBuYW1lc3BhY2VzIHdpdGggb3B0aW9uYWwgbWF0Y2ggY29uZGl0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnByZWZpeCBPcHRpb25hbCBsaXN0IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBwcmVmaXggdG8gZmlsdGVyIG5hbWVzcGFjZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3VmZml4IE9wdGlvbmFsIGxpc3Qgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIHN1ZmZpeCB0byBmaWx0ZXIgbmFtZXNwYWNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tYXhEZXB0aCBPcHRpb25hbCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG1heGltdW0gZGVwdGggb2YgbmFtZXNwYWNlcyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgTWF4aW11bSBudW1iZXIgb2YgbmFtZXNwYWNlcyB0byByZXR1cm4gKGRlZmF1bHQgaXMgMTAwKS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vZmZzZXQgTnVtYmVyIG9mIG5hbWVzcGFjZXMgdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMgKGRlZmF1bHQgaXMgMCkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxMaXN0TmFtZXNwYWNlUmVzcG9uc2U+XG4gICAgICovXG4gICAgYXN5bmMgbGlzdE5hbWVzcGFjZXMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgcHJlZml4OiBvcHRpb25zPy5wcmVmaXgsXG4gICAgICAgICAgICBzdWZmaXg6IG9wdGlvbnM/LnN1ZmZpeCxcbiAgICAgICAgICAgIG1heF9kZXB0aDogb3B0aW9ucz8ubWF4RGVwdGgsXG4gICAgICAgICAgICBsaW1pdDogb3B0aW9ucz8ubGltaXQgPz8gMTAwLFxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zPy5vZmZzZXQgPz8gMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvc3RvcmUvbmFtZXNwYWNlc1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjogcGF5bG9hZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIGFzc2lzdGFudHMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhc3Npc3RhbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRocmVhZHMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aHJlYWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHJ1bnMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIGNyb24gcnVucy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNyb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBLViBzdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXNzaXN0YW50cyA9IG5ldyBBc3Npc3RhbnRzQ2xpZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXMudGhyZWFkcyA9IG5ldyBUaHJlYWRzQ2xpZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXMucnVucyA9IG5ldyBSdW5zQ2xpZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY3JvbnMgPSBuZXcgQ3JvbnNDbGllbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBTdG9yZUNsaWVudChjb25maWcpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@langchain/langgraph-sdk/dist/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(ssr)/./node_modules/@langchain/langgraph-sdk/dist/client.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdXN0ZW4vRGV2ZWxvcG1lbnQvdXB3YWdlL2ludGVydmlldy1vcmNoZXN0cmF0aW9uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@langchain/langgraph-sdk/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(ssr)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(ssr)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    408, // Request Timeout\n    422, // Unprocessable Entity\n];\nconst STATUS_IGNORE = [\n    409, // Conflict\n];\n/**\n * Do not rely on globalThis.Response, rather just\n * do duck typing\n */\nfunction isResponse(x) {\n    if (x == null || typeof x !== \"object\")\n        return false;\n    return \"status\" in x && \"statusText\" in x && \"text\" in x;\n}\n/**\n * Utility error to properly handle failed requests\n */\nclass HTTPError extends Error {\n    constructor(status, message, response) {\n        super(`HTTP ${status}: ${message}`);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.status = status;\n        this.text = message;\n        this.response = response;\n    }\n    static async fromResponse(response, options) {\n        try {\n            return new HTTPError(response.status, await response.text(), options?.includeResponse ? response : undefined);\n        }\n        catch {\n            return new HTTPError(response.status, response.statusText, options?.includeResponse ? response : undefined);\n        }\n    }\n}\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 5. This\n * means that by default, each call will be retried up to 5 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"customFetch\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 4;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n        this.customFetch = params.fetch;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(() => p_retry__WEBPACK_IMPORTED_MODULE_0__(() => callable(...args).catch(async (error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else if (isResponse(error)) {\n                throw await HTTPError.fromResponse(error, {\n                    includeResponse: !!onFailedResponseHook,\n                });\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            async onFailedAttempt(error) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                if (error instanceof HTTPError) {\n                    if (STATUS_NO_RETRY.includes(error.status)) {\n                        throw error;\n                    }\n                    else if (STATUS_IGNORE.includes(error.status)) {\n                        return;\n                    }\n                    if (onFailedResponseHook && error.response) {\n                        await onFailedResponseHook(error.response);\n                    }\n                }\n            },\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        const fetchFn = this.customFetch ?? fetch;\n        return this.call(() => fetchFn(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUNHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyxJQUFJLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksS0FBc0I7QUFDbEM7QUFDQSw2QkFBNkIsK0NBQWlCO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBUyxHQUFHLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQ0FBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUssc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2p1c3Rlbi9EZXZlbG9wbWVudC91cHdhZ2UvaW50ZXJ2aWV3LW9yY2hlc3RyYXRpb24vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLCAvLyBCYWQgUmVxdWVzdFxuICAgIDQwMSwgLy8gVW5hdXRob3JpemVkXG4gICAgNDAyLCAvLyBQYXltZW50IHJlcXVpcmVkXG4gICAgNDAzLCAvLyBGb3JiaWRkZW5cbiAgICA0MDQsIC8vIE5vdCBGb3VuZFxuICAgIDQwNSwgLy8gTWV0aG9kIE5vdCBBbGxvd2VkXG4gICAgNDA2LCAvLyBOb3QgQWNjZXB0YWJsZVxuICAgIDQwNywgLy8gUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcbiAgICA0MDgsIC8vIFJlcXVlc3QgVGltZW91dFxuICAgIDQyMiwgLy8gVW5wcm9jZXNzYWJsZSBFbnRpdHlcbl07XG5jb25zdCBTVEFUVVNfSUdOT1JFID0gW1xuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vKipcbiAqIERvIG5vdCByZWx5IG9uIGdsb2JhbFRoaXMuUmVzcG9uc2UsIHJhdGhlciBqdXN0XG4gKiBkbyBkdWNrIHR5cGluZ1xuICovXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHgpIHtcbiAgICBpZiAoeCA9PSBudWxsIHx8IHR5cGVvZiB4ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIFwic3RhdHVzXCIgaW4geCAmJiBcInN0YXR1c1RleHRcIiBpbiB4ICYmIFwidGV4dFwiIGluIHg7XG59XG4vKipcbiAqIFV0aWxpdHkgZXJyb3IgdG8gcHJvcGVybHkgaGFuZGxlIGZhaWxlZCByZXF1ZXN0c1xuICovXG5jbGFzcyBIVFRQRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzLCBtZXNzYWdlLCByZXNwb25zZSkge1xuICAgICAgICBzdXBlcihgSFRUUCAke3N0YXR1c306ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRleHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMudGV4dCA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21SZXNwb25zZShyZXNwb25zZSwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIVFRQRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCBhd2FpdCByZXNwb25zZS50ZXh0KCksIG9wdGlvbnM/LmluY2x1ZGVSZXNwb25zZSA/IHJlc3BvbnNlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhUVFBFcnJvcihyZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQsIG9wdGlvbnM/LmluY2x1ZGVSZXNwb25zZSA/IHJlc3BvbnNlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNS4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDUgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRSZXNwb25zZUhvb2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3VzdG9tRmV0Y2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNDtcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWVNb2QoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rID0gcGFyYW1zPy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICAgICAgdGhpcy5jdXN0b21GZXRjaCA9IHBhcmFtcy5mZXRjaDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9uRmFpbGVkUmVzcG9uc2VIb29rID0gdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGF3YWl0IEhUVFBFcnJvci5mcm9tUmVzcG9uc2UoZXJyb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZVJlc3BvbnNlOiAhIW9uRmFpbGVkUmVzcG9uc2VIb29rLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGFzeW5jIG9uRmFpbGVkQXR0ZW1wdChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBIVFRQRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNUQVRVU19OT19SRVRSWS5pbmNsdWRlcyhlcnJvci5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTVEFUVVNfSUdOT1JFLmluY2x1ZGVzKGVycm9yLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob25GYWlsZWRSZXNwb25zZUhvb2sgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG9uRmFpbGVkUmVzcG9uc2VIb29rKGVycm9yLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZldGNoRm4gPSB0aGlzLmN1c3RvbUZldGNoID8/IGZldGNoO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCgpID0+IGZldGNoRm4oLi4uYXJncykudGhlbigocmVzKSA9PiAocmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/env.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable)\n/* harmony export */ });\nfunction getEnvironmentVariable(name) {\n    // Certain setups (Deno, frontend) will throw an error if you try to access environment variables\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdXN0ZW4vRGV2ZWxvcG1lbnQvdXB3YWdlL2ludGVydmlldy1vcmNoZXN0cmF0aW9uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9lbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gc2V0dXBzIChEZW5vLCBmcm9udGVuZCkgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/eventsource-parser/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/eventsource-parser/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createParser: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_0__.createParser)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/eventsource-parser/parse.js\");\n// From https://github.com/rexxars/eventsource-parser\n// Inlined due to CJS import issues\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvZXZlbnRzb3VyY2UtcGFyc2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUMwQyIsInNvdXJjZXMiOlsiL1VzZXJzL2p1c3Rlbi9EZXZlbG9wbWVudC91cHdhZ2UvaW50ZXJ2aWV3LW9yY2hlc3RyYXRpb24vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L3V0aWxzL2V2ZW50c291cmNlLXBhcnNlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXh4YXJzL2V2ZW50c291cmNlLXBhcnNlclxuLy8gSW5saW5lZCBkdWUgdG8gQ0pTIGltcG9ydCBpc3N1ZXNcbmV4cG9ydCB7IGNyZWF0ZVBhcnNlciB9IGZyb20gXCIuL3BhcnNlLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/eventsource-parser/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/eventsource-parser/parse.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/eventsource-parser/parse.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createParser: () => (/* binding */ createParser)\n/* harmony export */ });\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nfunction createParser(onParse) {\n    // Processing state\n    let isFirstChunk;\n    let buffer;\n    let startingPosition;\n    let startingFieldLength;\n    // Event state\n    let eventId;\n    let eventName;\n    let data;\n    reset();\n    return { feed, reset };\n    function reset() {\n        isFirstChunk = true;\n        buffer = \"\";\n        startingPosition = 0;\n        startingFieldLength = -1;\n        eventId = undefined;\n        eventName = undefined;\n        data = \"\";\n    }\n    function feed(chunk) {\n        buffer = buffer ? buffer + chunk : chunk;\n        // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n        // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n        // always decoded as UTF8 as per the specification.\n        if (isFirstChunk && hasBom(buffer)) {\n            buffer = buffer.slice(BOM.length);\n        }\n        isFirstChunk = false;\n        // Set up chunk-specific processing state\n        const length = buffer.length;\n        let position = 0;\n        let discardTrailingNewline = false;\n        // Read the current buffer byte by byte\n        while (position < length) {\n            // EventSource allows for carriage return + line feed, which means we\n            // need to ignore a linefeed character if the previous character was a\n            // carriage return\n            // @todo refactor to reduce nesting, consider checking previous byte?\n            // @todo but consider multiple chunks etc\n            if (discardTrailingNewline) {\n                if (buffer[position] === \"\\n\") {\n                    ++position;\n                }\n                discardTrailingNewline = false;\n            }\n            let lineLength = -1;\n            let fieldLength = startingFieldLength;\n            let character;\n            for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n                character = buffer[index];\n                if (character === \":\" && fieldLength < 0) {\n                    fieldLength = index - position;\n                }\n                else if (character === \"\\r\") {\n                    discardTrailingNewline = true;\n                    lineLength = index - position;\n                }\n                else if (character === \"\\n\") {\n                    lineLength = index - position;\n                }\n            }\n            if (lineLength < 0) {\n                startingPosition = length - position;\n                startingFieldLength = fieldLength;\n                break;\n            }\n            else {\n                startingPosition = 0;\n                startingFieldLength = -1;\n            }\n            parseEventStreamLine(buffer, position, fieldLength, lineLength);\n            position += lineLength + 1;\n        }\n        if (position === length) {\n            // If we consumed the entire buffer to read the event, reset the buffer\n            buffer = \"\";\n        }\n        else if (position > 0) {\n            // If there are bytes left to process, set the buffer to the unprocessed\n            // portion of the buffer only\n            buffer = buffer.slice(position);\n        }\n    }\n    function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {\n        if (lineLength === 0) {\n            // We reached the last line of this event\n            if (data.length > 0) {\n                onParse({\n                    type: \"event\",\n                    id: eventId,\n                    event: eventName || undefined,\n                    data: data.slice(0, -1), // remove trailing newline\n                });\n                data = \"\";\n                eventId = undefined;\n            }\n            eventName = undefined;\n            return;\n        }\n        const noValue = fieldLength < 0;\n        const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));\n        let step = 0;\n        if (noValue) {\n            step = lineLength;\n        }\n        else if (lineBuffer[index + fieldLength + 1] === \" \") {\n            step = fieldLength + 2;\n        }\n        else {\n            step = fieldLength + 1;\n        }\n        const position = index + step;\n        const valueLength = lineLength - step;\n        const value = lineBuffer.slice(position, position + valueLength).toString();\n        if (field === \"data\") {\n            data += value ? `${value}\\n` : \"\\n\";\n        }\n        else if (field === \"event\") {\n            eventName = value;\n        }\n        else if (field === \"id\" && !value.includes(\"\\u0000\")) {\n            eventId = value;\n        }\n        else if (field === \"retry\") {\n            const retry = parseInt(value, 10);\n            if (!Number.isNaN(retry)) {\n                onParse({ type: \"reconnect-interval\", value: retry });\n            }\n        }\n    }\n}\nconst BOM = [239, 187, 191];\nfunction hasBom(buffer) {\n    return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvZXZlbnRzb3VyY2UtcGFyc2VyL3BhcnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msa0NBQWtDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQTBDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdXN0ZW4vRGV2ZWxvcG1lbnQvdXB3YWdlL2ludGVydmlldy1vcmNoZXN0cmF0aW9uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9ldmVudHNvdXJjZS1wYXJzZXIvcGFyc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEV2ZW50U291cmNlIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0gb25QYXJzZSAtIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGEgbmV3IGV2ZW50IGlzIHBhcnNlZCwgb3IgYSBuZXcgcmVjb25uZWN0aW9uIGludGVydmFsXG4gKiAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIHNlbnQgZnJvbSB0aGUgc2VydmVyXG4gKlxuICogQHJldHVybnMgQSBuZXcgRXZlbnRTb3VyY2UgcGFyc2VyLCB3aXRoIGBwYXJzZWAgYW5kIGByZXNldGAgbWV0aG9kcy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhcnNlcihvblBhcnNlKSB7XG4gICAgLy8gUHJvY2Vzc2luZyBzdGF0ZVxuICAgIGxldCBpc0ZpcnN0Q2h1bms7XG4gICAgbGV0IGJ1ZmZlcjtcbiAgICBsZXQgc3RhcnRpbmdQb3NpdGlvbjtcbiAgICBsZXQgc3RhcnRpbmdGaWVsZExlbmd0aDtcbiAgICAvLyBFdmVudCBzdGF0ZVxuICAgIGxldCBldmVudElkO1xuICAgIGxldCBldmVudE5hbWU7XG4gICAgbGV0IGRhdGE7XG4gICAgcmVzZXQoKTtcbiAgICByZXR1cm4geyBmZWVkLCByZXNldCB9O1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICBzdGFydGluZ1Bvc2l0aW9uID0gMDtcbiAgICAgICAgc3RhcnRpbmdGaWVsZExlbmd0aCA9IC0xO1xuICAgICAgICBldmVudElkID0gdW5kZWZpbmVkO1xuICAgICAgICBldmVudE5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRhdGEgPSBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmZWVkKGNodW5rKSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciA/IGJ1ZmZlciArIGNodW5rIDogY2h1bms7XG4gICAgICAgIC8vIFN0cmlwIGFueSBVVEY4IGJ5dGUgb3JkZXIgbWFyayAoQk9NKSBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmVhbS5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvIG5vdCBzdHJpcCBhbnkgbm9uIC0gVVRGOCBCT00sIGFzIGV2ZW50c291cmNlIHN0cmVhbXMgYXJlXG4gICAgICAgIC8vIGFsd2F5cyBkZWNvZGVkIGFzIFVURjggYXMgcGVyIHRoZSBzcGVjaWZpY2F0aW9uLlxuICAgICAgICBpZiAoaXNGaXJzdENodW5rICYmIGhhc0JvbShidWZmZXIpKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoQk9NLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIC8vIFNldCB1cCBjaHVuay1zcGVjaWZpYyBwcm9jZXNzaW5nIHN0YXRlXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gZmFsc2U7XG4gICAgICAgIC8vIFJlYWQgdGhlIGN1cnJlbnQgYnVmZmVyIGJ5dGUgYnkgYnl0ZVxuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50U291cmNlIGFsbG93cyBmb3IgY2FycmlhZ2UgcmV0dXJuICsgbGluZSBmZWVkLCB3aGljaCBtZWFucyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBpZ25vcmUgYSBsaW5lZmVlZCBjaGFyYWN0ZXIgaWYgdGhlIHByZXZpb3VzIGNoYXJhY3RlciB3YXMgYVxuICAgICAgICAgICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICAgICAgICAvLyBAdG9kbyByZWZhY3RvciB0byByZWR1Y2UgbmVzdGluZywgY29uc2lkZXIgY2hlY2tpbmcgcHJldmlvdXMgYnl0ZT9cbiAgICAgICAgICAgIC8vIEB0b2RvIGJ1dCBjb25zaWRlciBtdWx0aXBsZSBjaHVua3MgZXRjXG4gICAgICAgICAgICBpZiAoZGlzY2FyZFRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXJbcG9zaXRpb25dID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICsrcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lTGVuZ3RoID0gLTE7XG4gICAgICAgICAgICBsZXQgZmllbGRMZW5ndGggPSBzdGFydGluZ0ZpZWxkTGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNoYXJhY3RlcjtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRpbmdQb3NpdGlvbjsgbGluZUxlbmd0aCA8IDAgJiYgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBidWZmZXJbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXIgPT09IFwiOlwiICYmIGZpZWxkTGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZExlbmd0aCA9IGluZGV4IC0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gXCJcXHJcIikge1xuICAgICAgICAgICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZUxlbmd0aCA9IGluZGV4IC0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBsaW5lTGVuZ3RoID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZUxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydGluZ1Bvc2l0aW9uID0gbGVuZ3RoIC0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdGaWVsZExlbmd0aCA9IGZpZWxkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdGaWVsZExlbmd0aCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VFdmVudFN0cmVhbUxpbmUoYnVmZmVyLCBwb3NpdGlvbiwgZmllbGRMZW5ndGgsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcG9zaXRpb24gKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNvbnN1bWVkIHRoZSBlbnRpcmUgYnVmZmVyIHRvIHJlYWQgdGhlIGV2ZW50LCByZXNldCB0aGUgYnVmZmVyXG4gICAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGJ5dGVzIGxlZnQgdG8gcHJvY2Vzcywgc2V0IHRoZSBidWZmZXIgdG8gdGhlIHVucHJvY2Vzc2VkXG4gICAgICAgICAgICAvLyBwb3J0aW9uIG9mIHRoZSBidWZmZXIgb25seVxuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50U3RyZWFtTGluZShsaW5lQnVmZmVyLCBpbmRleCwgZmllbGRMZW5ndGgsIGxpbmVMZW5ndGgpIHtcbiAgICAgICAgaWYgKGxpbmVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIGxhc3QgbGluZSBvZiB0aGlzIGV2ZW50XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb25QYXJzZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGV2ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLnNsaWNlKDAsIC0xKSwgLy8gcmVtb3ZlIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICBldmVudElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnROYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vVmFsdWUgPSBmaWVsZExlbmd0aCA8IDA7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gbGluZUJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyAobm9WYWx1ZSA/IGxpbmVMZW5ndGggOiBmaWVsZExlbmd0aCkpO1xuICAgICAgICBsZXQgc3RlcCA9IDA7XG4gICAgICAgIGlmIChub1ZhbHVlKSB7XG4gICAgICAgICAgICBzdGVwID0gbGluZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lQnVmZmVyW2luZGV4ICsgZmllbGRMZW5ndGggKyAxXSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgIHN0ZXAgPSBmaWVsZExlbmd0aCArIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGVwID0gZmllbGRMZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggKyBzdGVwO1xuICAgICAgICBjb25zdCB2YWx1ZUxlbmd0aCA9IGxpbmVMZW5ndGggLSBzdGVwO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpbmVCdWZmZXIuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdmFsdWVMZW5ndGgpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChmaWVsZCA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIGRhdGEgKz0gdmFsdWUgPyBgJHt2YWx1ZX1cXG5gIDogXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZCA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZCA9PT0gXCJpZFwiICYmICF2YWx1ZS5pbmNsdWRlcyhcIlxcdTAwMDBcIikpIHtcbiAgICAgICAgICAgIGV2ZW50SWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZCA9PT0gXCJyZXRyeVwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXRyeSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXRyeSkpIHtcbiAgICAgICAgICAgICAgICBvblBhcnNlKHsgdHlwZTogXCJyZWNvbm5lY3QtaW50ZXJ2YWxcIiwgdmFsdWU6IHJldHJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgQk9NID0gWzIzOSwgMTg3LCAxOTFdO1xuZnVuY3Rpb24gaGFzQm9tKGJ1ZmZlcikge1xuICAgIHJldHVybiBCT00uZXZlcnkoKGNoYXJDb2RlLCBpbmRleCkgPT4gYnVmZmVyLmNoYXJDb2RlQXQoaW5kZXgpID09PSBjaGFyQ29kZSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/eventsource-parser/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeSignals: () => (/* binding */ mergeSignals)\n/* harmony export */ });\nfunction mergeSignals(...signals) {\n    const nonZeroSignals = signals.filter((signal) => signal != null);\n    if (nonZeroSignals.length === 0)\n        return undefined;\n    if (nonZeroSignals.length === 1)\n        return nonZeroSignals[0];\n    const controller = new AbortController();\n    for (const signal of signals) {\n        if (signal?.aborted) {\n            controller.abort(signal.reason);\n            return controller.signal;\n        }\n        signal?.addEventListener(\"abort\", () => controller.abort(signal.reason), {\n            once: true,\n        });\n    }\n    return controller.signal;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc2lnbmFscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdXN0ZW4vRGV2ZWxvcG1lbnQvdXB3YWdlL2ludGVydmlldy1vcmNoZXN0cmF0aW9uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9zaWduYWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBtZXJnZVNpZ25hbHMoLi4uc2lnbmFscykge1xuICAgIGNvbnN0IG5vblplcm9TaWduYWxzID0gc2lnbmFscy5maWx0ZXIoKHNpZ25hbCkgPT4gc2lnbmFsICE9IG51bGwpO1xuICAgIGlmIChub25aZXJvU2lnbmFscy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKG5vblplcm9TaWduYWxzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIG5vblplcm9TaWduYWxzWzBdO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykge1xuICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoc2lnbmFsLnJlYXNvbiksIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IterableReadableStream: () => (/* binding */ IterableReadableStream)\n/* harmony export */ });\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdXN0ZW4vRGV2ZWxvcG1lbnQvdXB3YWdlL2ludGVydmlldy1vcmNoZXN0cmF0aW9uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFN1cHBvcnQgYXN5bmMgaXRlcmF0b3Igc3ludGF4IGZvciBSZWFkYWJsZVN0cmVhbXMgaW4gYWxsIGVudmlyb25tZW50cy5cbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmV4cG9ydCBjbGFzcyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWFkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5zdXJlUmVhZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IHRoaXMuZ2V0UmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGVycm9yZWRcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICAvLyBJZiB3cmFwcGVkIGluIGEgTm9kZSBzdHJlYW0sIGNhbmNlbCBpcyBhbHJlYWR5IGNhbGxlZC5cbiAgICAgICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gdGhpcy5yZWFkZXIuY2FuY2VsKCk7IC8vIGNhbmNlbCBmaXJzdCwgYnV0IGRvbid0IGF3YWl0IHlldFxuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIGZpcnN0XG4gICAgICAgICAgICBhd2FpdCBjYW5jZWxQcm9taXNlOyAvLyBub3cgYXdhaXQgaXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgdGhyb3coZSkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3RyZWFtc19BUEkvVXNpbmdfcmVhZGFibGVfc3RyZWFtcyNyZWFkaW5nX3RoZV9zdHJlYW1cbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5xdWV1ZSB0aGUgbmV4dCBkYXRhIGNodW5rIGludG8gb3VyIHRhcmdldCBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQXN5bmNHZW5lcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBnZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaXg6IGBlbHNlIGlmICh2YWx1ZSlgIHdpbGwgaGFuZyB0aGUgc3RyZWFtaW5nIHdoZW4gbnVsbGlzaCB2YWx1ZSAoZS5nLiBlbXB0eSBzdHJpbmcpIGlzIHB1bGxlZFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IGdlbmVyYXRvci5yZXR1cm4ocmVhc29uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@langchain/langgraph-sdk/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(ssr)/./node_modules/@langchain/langgraph-sdk/dist/index.js");


/***/ })

};
;